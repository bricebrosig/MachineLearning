# This file contains the data structures and scripts necessary to test my genetic
# algorithm on the classic route optimization problem
# 
# This means that both the members of the population will be defined here but generated by the 
# library function. Similarly the fitness function will be written here and passed over
# to the library to do the evaluation
# 
# this could maybe be a jupyter notebook so that we can see the cool printing of the maps
# This will primarily use a lot a gmmichaels code/design to test the library

import GeneticAlgorithm
import numpy as np
from random import random

def make_map(p_zero, N):
    # generates a random adjacency matrix representing the map for which we are 
    # finding an optimal path between two random points on the map
    #
    # :param p_zero: float between 0 and 1 representing the probability that a node doesn't exist in the map
    # :param N: the number of nodes in the graph
    my_map = np.zeros((N,N))  # create the NxN adjacency matrix
    
    for i in range(0, N):
        for j in range(0, i):
            if random() > p_zero:
                the_map[i][j] = random()
                the_map[j][i] = the_map[i][j]
    return the_map

def fitness(member, the_map):
    # TODO: in genetic we will have to have some way of passing all of the fitness parameters that anyones
    #       function might need. we shouldn't just require that they only have one parameter, the member, as that
    #       might force them into a certain design
    # TODO: we should, however, require that they return None should the fitness of a member be invalid
    # returns the fitness value for a solution
    # in this case, returns 1/distance which we want to maximize
    # 
    # :param member: the member for which we are scoring
    # :param the_map: the map that we are scoring for
    
    score = 0
    
    for i in range(1, len(route)):
        if (the_map[route[i-1]][route[i]] == 0) and i != len(the_map)-1:
            # print("WARNING: INVALID ROUTE")
            # print(route)
            # print(the_map)
            return None
        score = score + the_map[route[i-1]][route[i]]

    return score

def check_validity(map, member):
    # Checks the validity of a member of the population; this might be obsolete if using the
    # fitness returns none trick
    return

def show_map(the_map, route):
    # prints out the map using some sort of cool thing
    # 
    # :param the_map: the graph for which the route is a solution for
    # :param member: the solution/route for the graph
    ax = sns.heatmap(the_map)

    x=[0.5] + [x + 0.5 for x in route[0:len(route)-1]] + [len(the_map) - 0.5]
    y=[0.5] + [x + 0.5 for x in route[1:len(route)]] + [len(the_map) - 0.5]
    
    plt.plot(x, y, marker = 'o', linewidth=4, markersize=12, linestyle = "-", color='white')
    plt.savefig('images/new1000plot_%i.png' %(-1), dpi=300)
    plt.show()

if __name__ == "__main__":
    # to use GeneticAlgorithm we need to define our data structure - its shape and
    # the parameters for all the features
    # in our case it is a matrix whose values are either 0 or 1 as they represent a 
    # graph
    # 
    # then we need to define a fitness function that scores one of those data structures, 
    # called members, and at the same time decide if we need to minimize or maximize that function
    
    
    pass